#!/usr/bin/env python3
"""
vehicle_dynamics.py - FIXED: Standardized to nautical convention (0° = North, clockwise)

COORDINATE SYSTEM FIX:
- Removed the confusing "90.0 - heading" offset
- Now uses nautical convention consistently: 0° = North, 90° = East, etc.
- This eliminates the ~45-degree trajectory rotation when submerged

Uses actual SIMPLR-AUV specifications loaded from JSON config files generated by
make_vd_config.py from zero bubble optimization results.
"""

import math
import json
import glob
import os

class VehicleDynamics:
    def __init__(self, vehicle_state, dt=0.1, config_file=None):
        """Initialize with vehicle configuration from zero bubble optimization"""
        self.vehicle_state = vehicle_state
        self.dt = dt
        
        # Load configuration
        self.config = self.load_configuration()
        self.apply_configuration()
        
        # Initialize state tracking
        self.prev_vertical_velocity = 0.0
        self.prev_pitch_rate = 0.0
        
        self.print_configuration_summary()
    
    def load_configuration(self):
        """Load vehicle configuration from JSON file or use defaults"""
        
        config_file = self.find_latest_config()
        
        if config_file and os.path.exists(config_file):
            print(f"Loading vehicle configuration from: {config_file}")
            try:
                with open(config_file, 'r') as f:
                    config = json.load(f)
                return config
            except Exception as e:
                print(f"Error loading config file: {e}")
                print("Using default configuration")
                return self.get_default_config()
        else:
            print("No configuration file found, using default parameters")
            return self.get_default_config()
    
    def find_latest_config(self):
        """Find the most recent vehicle configuration file"""
        config_files = glob.glob('vehicle_config_*.json')
        if not config_files:
            return None
        config_files.sort(reverse=True)
        return config_files[0]
    
    def get_default_config(self):
        """Default configuration matching original hardcoded values"""
        return {
            'metadata': {
                'source': 'default_hardcoded',
                'description': 'Default vehicle parameters (hardcoded fallback)',
                'coordinate_system': 'nautical_fixed'
            },
            'vehicle_parameters': {
                'mass': 27.78,
                'total_weight_lb': 61.2,
                'length': 1.524,
                'width': 0.2032,
                'height': 0.3048,
                'cg_from_nose': 0.76073,
                'cg_height': 0.0,
                'surfaced_buoyancy': 4.4660145,
                'submerged_buoyancy': -0.0266,
                'I_yy': 6.2,
                'I_zz': 6.2,
                'cb_above_cg': 0.0254
            },
            'control_parameters': {
                'max_pitch_angle_deg': 15.0,
                'max_pitch_rate_deg_per_s': 10.0,
                'pitch_damping': 0.75,
                'pitch_rate_damping': 0.85,
                'vertical_damping': 0.85,
                'yaw_damping': 0.8,
                'min_control_speed_mps': 0.3,
                'control_speed_ramp_mps': 0.7
            }
        }
    
    def apply_configuration(self):
        """Apply loaded configuration to vehicle parameters"""
        
        vp = self.config['vehicle_parameters']
        cp = self.config['control_parameters']
        
        # VEHICLE PHYSICAL PARAMETERS from config
        self.mass = vp['mass']                    # kg
        self.length = vp['length']                # m
        self.hull_width = vp['width']            # m
        self.hull_height = vp.get('height', 0.3048)  # m
        
        # Center of mass and buoyancy from config
        self.cg_from_nose = vp['cg_from_nose']   # m
        self.cb_above_cg = vp['cb_above_cg']     # m
        
        # MOMENTS OF INERTIA from config
        self.I_yy = vp['I_yy']                   # kg*m^2
        self.I_zz = vp['I_zz']                   # kg*m^2
        
        # BUOYANCY FORCES from config
        self.surfaced_buoyancy = vp['surfaced_buoyancy']    # N
        self.submerged_buoyancy = vp['submerged_buoyancy']  # N
        
        # CONTROL PARAMETERS from config
        self.MAX_PITCH_ANGLE = math.radians(cp['max_pitch_angle_deg'])
        self.MAX_PITCH_RATE = math.radians(cp['max_pitch_rate_deg_per_s'])
        self.pitch_damping = cp['pitch_damping']
        self.pitch_rate_damping = cp['pitch_rate_damping']
        self.vertical_damping = cp['vertical_damping']
        self.yaw_damping = cp['yaw_damping']
        self.MIN_CONTROL_SPEED = cp['min_control_speed_mps']
        self.CONTROL_SPEED_RAMP = cp['control_speed_ramp_mps']
        
        # FIXED PROPULSION PARAMETERS (not typically optimized)
        self.max_thrust = 60.0              # N (actual motor specs)
        self.design_speed = 3.0             # m/s
        
        # FIXED FIN PARAMETERS (physical hardware)
        self.num_fins = 4
        self.fin_area_each = 0.00900387     # m² (13.9532 in² each)
        self.fin_total_area = self.fin_area_each * self.num_fins
        self.fin_moment_arm = 0.582476      # m (22.94" aft of CG)
        self.max_fin_deflection = 30.0      # degrees
        
        # FIXED AERODYNAMICS
        self.fin_lift_slope = 2.8           # per radian
        self.fin_stall_angle = 12.0         # degrees
        
        # FIXED HULL DRAG
        self.hull_drag_coeff = 0.12
        self.hull_ref_area = self.hull_width * self.hull_width
        
        # FIXED OPERATIONAL PARAMETERS
        self.rho_water = 1000.0             # kg/m³
        self.MAX_YAW_RATE = math.radians(20.0)
        self.DEPTH_TOLERANCE = 0.05
        self.MIN_VELOCITY_CHANGE = 0.001
        self.velocity_smoothing = 0.15
        self.restoring_moment_gain = 3.0
    
    def print_configuration_summary(self):
        """Print configuration summary showing what was loaded"""
        print("=== VEHICLE CONFIGURATION LOADED (NAUTICAL CONVENTION) ===")
        print(f"Source: {self.config['metadata'].get('source', 'unknown')}")
        print(f"Description: {self.config['metadata'].get('description', 'N/A')}")
        print("COORDINATE SYSTEM: Nautical (0° = North, 90° = East, clockwise)")
        
        if 'generated_date' in self.config['metadata']:
            print(f"Generated: {self.config['metadata']['generated_date']}")
        
        print(f"\nPhysical Parameters:")
        print(f"  Mass: {self.mass:.2f} kg ({self.config['vehicle_parameters'].get('total_weight_lb', 0):.1f} lb)")
        print(f"  Length: {self.length:.3f} m")
        print(f"  CG from nose: {self.cg_from_nose:.3f} m")
        print(f"  CB above CG: {self.cb_above_cg:.4f} m")
        print(f"  Pitch inertia (I_yy): {self.I_yy:.2f} kg⋅m²")
        print(f"  Yaw inertia (I_zz): {self.I_zz:.2f} kg⋅m²")
        
        print(f"\nBuoyancy Forces:")
        print(f"  Surfaced: {self.surfaced_buoyancy:+.2f} N")
        print(f"  Submerged: {self.submerged_buoyancy:+.2f} N")
        
        print(f"\nControl Parameters:")
        print(f"  Max pitch angle: ±{math.degrees(self.MAX_PITCH_ANGLE):.1f}°")
        print(f"  Max pitch rate: ±{math.degrees(self.MAX_PITCH_RATE):.1f}°/s")
        print(f"  Pitch damping: {self.pitch_damping:.2f}")
        print(f"  Pitch rate damping: {self.pitch_rate_damping:.2f}")
        print(f"  Vertical damping: {self.vertical_damping:.2f}")
        print(f"  Yaw damping: {self.yaw_damping:.2f}")
        print(f"  Min control speed: {self.MIN_CONTROL_SPEED:.1f} m/s")
        
        # Show zero bubble optimization results if available
        if 'lead_weights' in self.config['vehicle_parameters']:
            lead_info = self.config['vehicle_parameters']['lead_weights']
            print(f"\nZero Bubble Optimization Results:")
            print(f"  Lead weights: {lead_info['count']} units, {lead_info['total_weight_lb']:.1f} lb")
            
        if 'foam_blocks' in self.config['vehicle_parameters']:
            foam_info = self.config['vehicle_parameters']['foam_blocks']
            print(f"  Foam blocks: {foam_info['count']} blocks, {foam_info['total_volume_in3']:.0f} in³")
        
        print("COORDINATE FIX: Removed 90° offset - now using direct nautical headings")
        print("=" * 65)
    
    def _get_buoyancy_force(self):
        """Get buoyancy force based on ballast state"""
        if self.vehicle_state.buoyancy_state == "POSITIVE":
            return self.surfaced_buoyancy
        elif self.vehicle_state.buoyancy_state == "NEUTRAL":
            return self.submerged_buoyancy
        else:
            return self.submerged_buoyancy
    
    def _thruster_force(self, thruster_cmd_percent):
        """Convert thruster command to force"""
        cmd_limited = max(0.0, min(100.0, float(thruster_cmd_percent)))
        return (cmd_limited / 100.0) * self.max_thrust
    
    def _hull_drag_force(self, speed):
        """Calculate hull drag force"""
        return 0.5 * self.rho_water * self.hull_drag_coeff * self.hull_ref_area * speed * abs(speed)
    
    def _speed_effectiveness_factor(self, speed):
        """Calculate fin effectiveness based on speed"""
        if speed < self.MIN_CONTROL_SPEED:
            return (speed / self.MIN_CONTROL_SPEED) ** 2
        elif speed < (self.MIN_CONTROL_SPEED + self.CONTROL_SPEED_RAMP):
            ramp_fraction = (speed - self.MIN_CONTROL_SPEED) / self.CONTROL_SPEED_RAMP
            return (speed / self.MIN_CONTROL_SPEED) ** 2 + ramp_fraction * (1.0 - (speed / self.MIN_CONTROL_SPEED) ** 2)
        else:
            return 1.0
    
    def _x_tail_fin_forces(self, ul, ur, lr, ll, speed):
        """Calculate X-tail fin forces and moments"""
        ul = float(ul) if ul is not None else 0.0
        ur = float(ur) if ur is not None else 0.0
        lr = float(lr) if lr is not None else 0.0
        ll = float(ll) if ll is not None else 0.0
        
        speed_factor = self._speed_effectiveness_factor(speed)
        
        if speed_factor < 0.01:
            return 0.0, 0.0, 0.0
        
        # X-tail mixing
        elevator_cmd = ((ul + ur) - (ll + lr)) / 4.0
        rudder_cmd = ((ul + lr) - (ur + ll)) / 4.0
        
        # Convert to angles
        elevator_angle_deg = (elevator_cmd / 100.0) * self.max_fin_deflection
        rudder_angle_deg = (rudder_cmd / 100.0) * self.max_fin_deflection
        
        elevator_angle_rad = math.radians(elevator_angle_deg)
        rudder_angle_rad = math.radians(rudder_angle_deg)
        
        # Dynamic pressure
        q = 0.5 * self.rho_water * speed**2
        
        # Pitch forces and moment
        if abs(elevator_angle_deg) <= self.fin_stall_angle:
            cl_elevator = self.fin_lift_slope * elevator_angle_rad
        else:
            cl_elevator = 1.2 * math.copysign(1.0, elevator_angle_rad)
        
        pitch_force = q * cl_elevator * self.fin_total_area * speed_factor * 1.2
        pitch_moment = pitch_force * self.fin_moment_arm
        
        # Yaw moment
        effective_rudder_area = self.fin_total_area * 0.6
        
        if abs(rudder_angle_deg) <= self.fin_stall_angle:
            cl_rudder = self.fin_lift_slope * rudder_angle_rad
        else:
            cl_rudder = 1.0 * math.copysign(1.0, rudder_angle_rad)
        
        yaw_force = q * cl_rudder * effective_rudder_area * speed_factor
        yaw_moment = yaw_force * self.fin_moment_arm
        
        return pitch_force, pitch_moment, yaw_moment
    
    def _smooth_velocity_change(self, current_velocity, new_velocity):
        """Smooth velocity changes for numerical stability"""
        velocity_change = new_velocity - current_velocity
        
        if abs(velocity_change) < self.MIN_VELOCITY_CHANGE:
            return current_velocity
        
        smoothed_change = velocity_change * (1.0 - self.velocity_smoothing)
        return current_velocity + smoothed_change
    
    def _smooth_pitch_rate_change(self, current_rate, new_rate):
        """Smooth pitch rate changes to prevent oscillations"""
        rate_change = new_rate - current_rate
        smoothed_change = rate_change * (1.0 - self.pitch_rate_damping)
        return current_rate + smoothed_change
    
    def _update_depth_safely(self, current_depth, vertical_velocity, timestep):
        """Enhanced depth update with improved numerical stability"""
        new_depth = current_depth - vertical_velocity * timestep
        
        if new_depth < -self.DEPTH_TOLERANCE:
            constrained_depth = 0.0
            surface_hit = True
        else:
            constrained_depth = max(0.0, new_depth)
            surface_hit = False
        
        return constrained_depth, surface_hit
    
    def update(self, dt=None):
        """FIXED: Update vehicle dynamics using nautical convention (0° = North, clockwise)"""
        timestep = dt if dt is not None else self.dt
        if timestep <= 0:
            return
        
        with self.vehicle_state._state_lock:
            # Get current state
            ts = self.vehicle_state.true_state
            ac = getattr(self.vehicle_state, 'actuator_commands', {})
            
            current_speed = ts.get('true_speed', 0.0)
            current_depth = ts.get('true_depth', 0.0)
            current_heading = ts.get('true_heading', 0.0)
            current_pitch = ts.get('true_pitch', 0.0)
            current_vz = ts.get('true_vertical_velocity', 0.0)
            current_pitch_rate = ts.get('true_pitch_rate', 0.0)
            current_yaw_rate = ts.get('true_yaw_rate', 0.0)
            
            # Get control inputs
            thruster_cmd = ac.get('thruster_cmd', 0.0)
            ul = ac.get('UL', 0.0)
            ur = ac.get('UR', 0.0)
            lr = ac.get('LR', 0.0)
            ll = ac.get('LL', 0.0)
            
            # --- SURGE (Forward Motion) ---
            thrust = self._thruster_force(thruster_cmd)
            drag = self._hull_drag_force(current_speed)
            
            net_force_x = thrust - drag
            accel_x = net_force_x / self.mass
            
            new_speed = current_speed + accel_x * timestep
            ts['true_speed'] = max(0.0, new_speed)
            
            # --- FIN FORCES AND MOMENTS ---
            pitch_force, pitch_moment, yaw_moment = self._x_tail_fin_forces(
                ul, ur, lr, ll, ts['true_speed'])
            
            # --- PITCH DYNAMICS ---
            # Buoyancy restoring moment using config parameters
            buoyancy_restoring_moment = (self._get_buoyancy_force() * self.cb_above_cg * 
                                       math.sin(current_pitch) * self.restoring_moment_gain)
            
            total_pitch_moment = pitch_moment - buoyancy_restoring_moment
            
            # Pitch acceleration using config inertia
            pitch_accel = total_pitch_moment / self.I_yy
            new_pitch_rate = current_pitch_rate + pitch_accel * timestep
            
            # Apply smoothing and limits using config parameters
            smoothed_pitch_rate = self._smooth_pitch_rate_change(current_pitch_rate, new_pitch_rate)
            limited_pitch_rate = max(-self.MAX_PITCH_RATE, min(self.MAX_PITCH_RATE, smoothed_pitch_rate))
            final_pitch_rate = limited_pitch_rate * self.pitch_damping
            ts['true_pitch_rate'] = final_pitch_rate
            
            # Update pitch angle with config limits
            new_pitch = current_pitch + ts['true_pitch_rate'] * timestep
            ts['true_pitch'] = max(-self.MAX_PITCH_ANGLE, min(self.MAX_PITCH_ANGLE, new_pitch))
            
            self.prev_pitch_rate = ts['true_pitch_rate']
            
            # --- YAW DYNAMICS ---
            yaw_accel = yaw_moment / self.I_zz  # Using config inertia
            new_yaw_rate = current_yaw_rate + yaw_accel * timestep
            limited_yaw_rate = max(-self.MAX_YAW_RATE, min(self.MAX_YAW_RATE, new_yaw_rate))
            damped_yaw_rate = limited_yaw_rate * self.yaw_damping  # Using config damping
            ts['true_yaw_rate'] = damped_yaw_rate
            
            # Update heading - FIXED: Use nautical convention directly
            heading_change_deg = math.degrees(ts['true_yaw_rate'] * timestep)
            ts['true_heading'] = (current_heading + heading_change_deg) % 360.0
            
            # --- VERTICAL MOTION ---
            buoyancy = self._get_buoyancy_force()  # Using config buoyancy values
            
            # Dynamic diving
            if ts['true_speed'] > 0.2:
                dynamic_lift = -1.2 * self.rho_water * ts['true_speed']**2 * self.hull_ref_area * math.sin(ts['true_pitch'])
            else:
                dynamic_lift = 0.0
            
            elevator_vertical_force = pitch_force * 0.6
            vertical_drag = 15.0 * current_vz * abs(current_vz)
            
            net_force_z = buoyancy + dynamic_lift + elevator_vertical_force - vertical_drag
            accel_z = net_force_z / self.mass  # Using config mass
            new_vz = current_vz + accel_z * timestep
            
            smoothed_vz = self._smooth_velocity_change(current_vz, new_vz)
            final_vz = smoothed_vz * self.vertical_damping  # Using config damping
            ts['true_vertical_velocity'] = max(-2.0, min(2.0, final_vz))
            
            self.prev_vertical_velocity = ts['true_vertical_velocity']
            
            # --- DEPTH UPDATE ---
            new_depth, surface_constraint_triggered = self._update_depth_safely(
                current_depth, ts['true_vertical_velocity'], timestep)
            
            ts['true_depth'] = new_depth
            
            if surface_constraint_triggered and ts['true_vertical_velocity'] > 0.0:
                ts['true_vertical_velocity'] = 0.0
                self.prev_vertical_velocity = 0.0
            
            # --- POSITION UPDATE - FIXED: Direct nautical heading usage ---
            if ts['true_speed'] > 0.01:
                # FIXED: Use heading directly in nautical convention
                # 0° = North, 90° = East, 180° = South, 270° = West
                heading_rad = math.radians(ts['true_heading'])
                
                # Nautical to mathematical conversion for trig functions
                # Mathematical: 0° = East, counter-clockwise
                # Nautical: 0° = North, clockwise
                # Convert: math_angle = 90° - nautical_angle
                math_heading_rad = math.radians(90.0 - ts['true_heading'])
                
                dx = ts['true_speed'] * math.cos(math_heading_rad) * timestep  # East component
                dy = ts['true_speed'] * math.sin(math_heading_rad) * timestep  # North component
                
                deg_per_meter_lat = 1.0 / 111320.0
                current_lat = ts.get('true_lat', 0.0)
                deg_per_meter_lon = 1.0 / (111320.0 * math.cos(math.radians(current_lat)))
                
                ts['true_lat'] = ts.get('true_lat', 0.0) + dy * deg_per_meter_lat  # North
                ts['true_lon'] = ts.get('true_lon', 0.0) + dx * deg_per_meter_lon  # East
    
    def get_state_summary(self):
        """Return vehicle state summary including configuration info"""
        with self.vehicle_state._state_lock:
            ts = self.vehicle_state.true_state
            speed_factor = self._speed_effectiveness_factor(ts.get('true_speed', 0.0))
            pitch_deg = math.degrees(ts.get('true_pitch', 0.0))
            pitch_rate_deg = math.degrees(ts.get('true_pitch_rate', 0.0))
            
            return {
                'speed': f"{ts.get('true_speed', 0.0):.2f} m/s",
                'depth': f"{ts.get('true_depth', 0.0):.2f} m", 
                'heading': f"{ts.get('true_heading', 0.0):.1f}° (nautical)",
                'pitch': f"{pitch_deg:+.1f}° (limit: ±{math.degrees(self.MAX_PITCH_ANGLE):.0f}°)",
                'pitch_rate': f"{pitch_rate_deg:+.1f}°/s (limit: ±{math.degrees(self.MAX_PITCH_RATE):.0f}°/s)",
                'vz': f"{ts.get('true_vertical_velocity', 0.0):+.3f} m/s",
                'buoyancy': f"{self._get_buoyancy_force():+.3f} N",
                'speed_factor': f"{speed_factor:.2f}",
                'state': self.vehicle_state.buoyancy_state,
                'config_source': self.config['metadata'].get('source', 'unknown'),
                'mass': f"{self.mass:.2f} kg",
                'cg_position': f"{self.cg_from_nose:.3f} m from nose",
                'coordinate_system': 'nautical_fixed',
                'zero_bubble_optimized': 'lead_weights' in self.config['vehicle_parameters']
            }